---
// Word of warning: this component is full of bodges.

import type { GraphConfig, Sitemap } from 'starlight-site-graph/config';
import { Graph } from 'starlight-site-graph/components'
import { Tabs, TabItem, Code } from '@astrojs/starlight/components';
import prettier from 'prettier/standalone';
import * as prettierPluginBabel from "prettier/plugins/babel";
import * as prettierPluginEstree from "prettier/plugins/estree";

interface Props {
	slug: string;
	config: GraphConfig;
	baseConfig: object;
	sitemap: Sitemap;
	id: string;
	buttons?: Record<string, {
		class: string;
		config: object;
	}>;
	sliders?: Record<string, {
		title: string;
		val: number;
		min: number;
		max: number;
		step: number;
		type?: "percentage";
	}>;
	dropdowns?: Record<string, Record<string, object>>;
	dropdownMergeOrder?: string[];
	dropdownDefaults?: Record<string, number>;
	configListener?: boolean;
	fullWidth: boolean;
}
const { baseConfig, config, sitemap, slug, id, buttons, sliders, dropdowns, dropdownMergeOrder, dropdownDefaults, configListener, fullWidth } = Astro.props;


export function isObject(item: unknown) {
	return (item && typeof item === 'object' && !Array.isArray(item));
}

export function mergeDeep(target: any, source: any) {
	let output = Object.assign({}, target);
	if (isObject(target) && isObject(source)) {
		Object.keys(source).forEach(key => {
			if (isObject(source[key])) {
				if (!(key in target))
					Object.assign(output, { [key]: source[key] });
				else
					output[key] = mergeDeep(target[key], source[key]);
			} else {
				Object.assign(output, { [key]: source[key] });
			}
		});
	}
	return output;
}

export function getNestedValue(obj: any, key: string) {
	return key.split('.').reduce((acc, key) => acc[key], obj);
}

export async function prettyPrintJSON(obj: any) {
	return await prettier.format(
		JSON.stringify(obj, null, 2),
		{
			parser: "json",
			// @ts-expect-error Type is wrong
			plugins: [prettierPluginBabel, prettierPluginEstree as string],
			printWidth: 36,
			objectWrap: "collapse",
		}
	);
}


const fullConfig = mergeDeep(baseConfig, config);
fullConfig.sitemapConfig.contentRoot = undefined;
fullConfig.sitemapConfig.sitemap = undefined;

const prettyConfig = await prettyPrintJSON(config);
const prettySitemap = await prettyPrintJSON(sitemap);
const prettyFullConfig = await prettyPrintJSON(fullConfig);


---

<div id={id} class="graph-example" >
	<div class={(fullWidth ? "items-full-width " : "") + "place-aside" }>
		<Graph
			config={fullConfig.graphConfig ?? {}}
			sitemap={sitemap}
			slug={slug}
		/>

		<Tabs>
			<TabItem label="Config" icon="setting">
				<Code code={prettyConfig} lang="json"/>
			</TabItem>
			<TabItem label="Sitemap" icon="seti:graphql">
				<Code code={prettySitemap} lang="json"/>
			</TabItem>
			<TabItem label="Full Config" icon="seti:json">
				<Code code={prettyFullConfig} lang="json"/>
			</TabItem>
		</Tabs>

		<div class="user-config">
			{Object.keys(buttons ?? {}).length !== 0 &&
				<div class="flex-row unselectable">
					{
						Object.entries(buttons!).map(([key, { class: className }]) => (
							<div class={className}>
								<button>{key}</button>
							</div>
						))
					}
				</div>
			}

			{Object.keys(sliders ?? {}).length !== 0 &&
				<div class="flex-column unselectable">
					{
						Object.entries(sliders!).map(([key, value]) => (
							// EXPL: slider is hidden if the initial value is nullish (to only show shapePoints slider if the shape is polygon/star)
							<div style=`display: ${ getNestedValue(config, key) ? 'unset' : 'none' }`>
								<span class="slider-title"> { value.title } </span>
								<input data-key={key} type="range" min={value.min} max={value.max} step={value.step} value={value.val} />
								<span class="slider-value"> { value.val + (value.type === "percentage" ? "%" : "") } </span>
							</div>
						))
					}
				</div>
			}

			{Object.keys(dropdowns ?? {}).length !== 0 &&
				<div class="flex-column unselectable">
					{Object.entries(dropdowns!).map(([key, value]) => (
						<div>
							<span class="dropdown-title">{key}</span>
							<select data-key={key}>
								{Object.entries(value).map(([k, v], idx) => (
									(
										<option
											data-selected={dropdownDefaults?.[key] === idx ? 'true' : 'false'}
											value={JSON.stringify(v)}
										>
											{k}
										</option>
									)
								))}
							</select>
						</div>
					))}
				</div>
			}
		</div>
	</div>


</div>

<script define:vars={{ id, buttons, sliders, dropdowns, dropdownMergeOrder, configListener }}>
	const isObject = i => i && typeof i == 'object' && !Array.isArray(i);
	const mergeDeep = (t, s) => (isObject(t) && isObject(s)) ? Object.keys(s).reduce((o, k) => (o[k] = isObject(s[k]) ? mergeDeep(t[k]||{}, s[k]) : s[k], o), {...t}) : t;
	const getPrimitives = (o, p = '') => Object.entries(o).flatMap(([k,v]) => typeof v === 'object' ? getPrimitives(v, p + k + '.') : [[p + k, v]]);
	const getNestedKey = (o, k) => k.split('.').reduce((a, c) => a[c], o);
	const transformNestedKeys = o => Object.keys(o).reduce((r, k) => {
		k.split('.').reduce((a, b, i, arr) => a[b] || (a[b] = i === arr.length - 1 ? o[k] : {}), r);
		return r;
	}, {});

	// Bodgy way to update the config (without importing remark code generation here)
	const updateTabText = (tab, partialConfig) => {
		const code = document.querySelectorAll(`#${id} starlight-tabs code`)[tab];
		const spans = Array.from(code.getElementsByTagName('span'));

		for (const [key, value] of getPrimitives(partialConfig)) {
			const keys = key.split('.');

			let current_idx = 0;
			let current_key = keys.shift();
			for (const span of spans) {
				if (span.nextSibling?.innerText.startsWith(":") && span.innerText.replace(/['"]/g, '') === current_key) {
					current_idx = spans.indexOf(span);
					current_key = keys.shift();
					if (!current_key) break;
				}
			}

			let array_pos = current_key?.match(/^\d+$/) ? parseInt(current_key) : -1;

			if (!current_key || array_pos !== -1) {
				current_idx += 2; // Skips current key and ":" spans
				if (spans[current_idx]?.classList.contains('indent')) current_idx += 1;
				if (value !== "undefined" && typeof value === 'string') current_idx += 1;

				const valueSpan = spans[current_idx];
				if (valueSpan) {
					if (value === "undefined") {
						valueSpan.parentElement.parentElement.style.display = "none";
					} else {
						valueSpan.parentElement.parentElement.style.display = "unset";
						valueSpan.textContent = value;
					}
				}
			}
		}
	};

	if (id) {
		const graph = document.querySelector(`#${id} graph-component`);
		const buttonEls = document.querySelectorAll(`#${id} button`);
		const sliderEls = document.querySelectorAll(`#${id} input`);
		const dropdownEls = document.querySelectorAll(`#${id} select`);

		// If some value in config is 'undefined' initially, execute updateTabText
		const initialConfig = { graphConfig: JSON.parse(graph.getAttribute('data-config')) };
		updateTabText(0, initialConfig);
		updateTabText(2, initialConfig);

		if (configListener) {
			const observer = new MutationObserver(() => {
				const config = { graphConfig: JSON.parse(graph.getAttribute('data-config')) };
				updateTabText(0, config);
				updateTabText(2, config);
			});
			observer.observe(graph, { attributes: true });
		}

		buttonEls.forEach(button => {
			button.addEventListener('click', () => {
				const config = { graphConfig: JSON.parse(graph.getAttribute('data-config')) };
				const newConfig = buttons[button.textContent].config;

				graph.setAttribute('data-config', JSON.stringify(mergeDeep(config, newConfig).graphConfig));
				if (!configListener) {
					updateTabText(0, newConfig);
					updateTabText(2, newConfig);
				}
				sliderEls.forEach(slider => {
					const key = slider.getAttribute('data-key');
					const value = getNestedKey(newConfig, key);
					if (value === 'undefined') {
						slider.parentElement.style.display = 'none';
					} else if (value !== undefined) {
						slider.value = value;
						slider.nextElementSibling.textContent = value;
						slider.parentElement.style.display = 'unset';
					}
				});
			});
		});

		sliderEls.forEach(slider => {
			slider.value = sliders[slider.getAttribute('data-key')].val;

			slider.addEventListener('input', () => {
				const config = { graphConfig: JSON.parse(graph.getAttribute('data-config')) };
				const configKey = slider.getAttribute('data-key')
				const newConfig = configKey.split('.').reverse().reduce((acc, key) => ({ [key]: acc }),
					sliders[configKey].type === "percentage" ? slider.value + "%" : Number(slider.value)
				);
				graph.setAttribute('data-config', JSON.stringify(mergeDeep(config, newConfig).graphConfig));
				if (!configListener) {
					updateTabText(0, newConfig);
					updateTabText(2, newConfig);
				}
				slider.nextElementSibling.textContent = sliders[configKey].type === "percentage" ? slider.value + "%" : slider.value;
			});
		});

		dropdownEls.forEach(dropdown => {
			for (const options of dropdown.options) {
				options.selected = options.getAttribute('data-selected') === 'true';
			}

			dropdown.addEventListener('change', () => {
				const config = { graphConfig: JSON.parse(graph.getAttribute('data-config')) };
				let newConfig = {};
				debugger
				if (dropdownMergeOrder) {
					const dropdownElements = Array.from(dropdownEls);
					let previousConfig = {};
					for (const key of dropdownMergeOrder) {
						const dropdownValue = transformNestedKeys(JSON.parse(dropdownElements.find(el => el.getAttribute('data-key') === key).value))["graphConfig"][key];
						previousConfig = mergeDeep(previousConfig, dropdownValue);
						newConfig[key] = previousConfig;
					}
				} else {
					newConfig = transformNestedKeys(JSON.parse(dropdown.value).graphConfig);
				}
				debugger;
				graph.setAttribute('data-config', JSON.stringify(mergeDeep(config.graphConfig, newConfig)));
				if (!configListener) {
					updateTabText(0, newConfig);
					updateTabText(2, newConfig);
				}
			});
		});
	}
</script>

<style>
    .unselectable {
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        -o-user-select: none;
        user-select: none;
    }

	.graph-example.graph-example {
        margin-top: 0;
        margin-bottom: 0;
    }

	.place-aside {
		display: flex;
		flex-direction: row;
		flex-wrap: wrap;
		gap: 1rem;
		padding-bottom: 1rem;

        .slsg-graph-component {
			flex-grow: 1;
            flex-basis: 30%;
			min-width: 250px;
			margin-top: 2rem;
			height: 320px;

			.slsg-graph-container:not(.slsg-is-fullscreen) {
				width: 100%;
			}
        }

		/** Todo: unset height on media <768px */
        starlight-tabs {
			flex-grow: 1;
			flex-basis: 5%;
			min-width: fit-content;
			height: 335px;

            .expressive-code {
				code {
					font-size: 0.8rem;
                    max-height: 280px;
                    overflow: auto;
                    scrollbar-color: var(--sl-color-gray-5) transparent;
				}
            }
        }
    }

	.user-config {
		width: 100%;
	}
</style>
