---
import type { GraphConfig } from '../config';
import type { Sitemap } from '../types';

interface Props {
    slug: string;
    config: GraphConfig;
    sitemap: Sitemap | undefined;
}


const { config, sitemap, slug } = Astro.props;
---

<graph-component data-config={JSON.stringify(config)} data-sitemap={JSON.stringify(sitemap)} data-slug={slug}></graph-component>

<script>
	import { prefetch } from 'astro:prefetch';
	import * as d3 from 'd3';
	import * as PIXI from './pixi/pixi';
	import type { GraphConfig, NodeStyle } from '../config';
	import { Animator } from './animator';
	import { showContextMenu } from './context-menu';
	import {
		addToVisitedEndpoints,
		createValueSlider,
		getVisitedEndpoints,
		onClickOutside,
		simplifySlug,
		stripSlashes,
		ensureLeadingSlash,
		ensureTrailingSlash,
		isMobileDevice,
		hasTouch,
	} from './util';
	import type { LinkData, NodeData } from './types';
	import type { Sitemap } from '../types';
	import { animatables, animated_colors } from './animatables';
	import { icons } from './icons';
	import { getGraphColors, type GraphColorConfig } from '../color';
	import {showPopupMenu} from "./popup-menu";

    const MAX_DEPTH = 6;

	export class GraphComponent extends HTMLElement {
		static observedValues = ["config", "sitemap"];

		graphContainer: HTMLElement;
		mockGraphContainer: HTMLElement;
		actionContainer: HTMLElement;
		blurContainer: HTMLElement;

		app!: PIXI.Application;
		simulation!: d3.Simulation<NodeData, undefined>;
		zoomBehavior!: d3.ZoomBehavior<HTMLCanvasElement, unknown>;
		zoomTransform: d3.ZoomTransform;
		centerTransform: d3.ZoomTransform;
		animateZoomOverride: boolean = false;
		transform: d3.ZoomTransform;
		userZoomed: boolean = false;
		currentNode: NodeData | undefined;
		lastClick: number = 0;
		lastClickedNode: NodeData | undefined;

		links!: PIXI.Graphics;
		arrows!: PIXI.Graphics;

        scale!: number;
		config!: GraphConfig;
		sitemap!: Sitemap;

		defaultColorTransitions = Object.fromEntries(animated_colors.flatMap(color => [
			[`${color}`, "default"],
			[`${color}Hover`, "default"],
		]));
		hoverColorTransitions = Object.fromEntries(animated_colors.flatMap(color => [
			[`${color}`, "blur"],
			[`${color}Hover`, "hover"],
		]));
		colors!: GraphColorConfig;
		processedData!: ReturnType<typeof this.processSitemapData>;
		animator: Animator<ReturnType<typeof animatables>>;

		currentlyHovered: string = '';
		isHovering: boolean = false;
		isFullscreen: boolean = false;
		fullscreenExitHandler?: (options?: (boolean | EventListenerOptions | undefined)) => void;

		currentPage!: string;
		requireDblClick: boolean;

		visitedPages: Set<string>;

		themeObserver: MutationObserver;

		constructor() {
			super();

			try {
				this.config = JSON.parse(this.dataset['config'] || '{}');
			} catch (e) { console.error("[SITE GRAPH PLUGIN] " + (e instanceof Error ? e.message : e)); }
			try {
				this.sitemap = JSON.parse(this.dataset['sitemap'] || '{}');
			} catch (e) { console.error("[SITE GRAPH PLUGIN] " + (e instanceof Error ? e.message : e)); }
            try {
                this.currentPage = ensureTrailingSlash(this.dataset['slug'] || stripSlashes(location.pathname));
            } catch (e) { console.error("[SITE GRAPH PLUGIN] " + (e instanceof Error ? e.message : e)); }

			this.config.depth = Math.min(this.config.depth, 5);

			if (this.config.trackVisitedPages) {
				this.visitedPages = getVisitedEndpoints();
			} else {
				this.visitedPages = new Set();
			}

			this.zoomTransform = d3.zoomIdentity;
			this.centerTransform = d3.zoomIdentity;
			this.transform = d3.zoomIdentity;

			this.classList.add('graph-component');

			this.graphContainer = document.createElement('div');
			this.graphContainer.classList.add('graph-container');
			this.graphContainer.onkeyup = e => {
				if (e.key === 'f') this.enableFullscreen();
			};
			this.graphContainer.tabIndex = 0;
			this.appendChild(this.graphContainer);

			this.actionContainer = document.createElement('div');
			this.actionContainer.classList.add('graph-action-container');
			this.renderActionContainer();
			this.graphContainer.appendChild(this.actionContainer);

			this.mockGraphContainer = document.createElement('div');
			this.mockGraphContainer.classList.add('graph-container');

			this.blurContainer = document.createElement('div');
			this.blurContainer.classList.add('background-blur');

			this.colors = getGraphColors(this.graphContainer);

			this.animator = new Animator<ReturnType<typeof animatables>>(animatables(this.config, this.colors));
			this.requireDblClick = this.config.clickMode === "auto" ? isMobileDevice() && hasTouch() : this.config.clickMode === "dblclick";
			this.themeObserver = new MutationObserver(() => {
				this.colors = getGraphColors(this.graphContainer);
				for (const color of animated_colors) {
					const key = color.slice(0, color.indexOf("Color") + 5);
					this.animator.setProperties(`${color}`, {
						"default": this.colors[color],
						"blur": this.colors[key + "Muted" as keyof GraphColorConfig],
					});
					this.animator.setProperties(`${color}Hover`, {
						"default": this.colors[color],
						"hover": this.colors[key + "Hover" as keyof GraphColorConfig],
					});
				}

				this.animator.startAnimationsTo(this.defaultColorTransitions, { duration: 500 });
				this.resetNodeFill();
			});
			this.themeObserver.observe(document.querySelector(":root")!, {
				attributeFilter: ["data-theme"],
			});

			this.mountGraph().then(() => {
				this.setup();
			});
		}

		override remove() {
			this.app.destroy();
			this.graphContainer.remove();
			this.mockGraphContainer.remove();
			this.blurContainer.remove();
			this.themeObserver.disconnect();

			super.remove();
		}

		enableFullscreen() {
			if (this.isFullscreen) return;

			this.isFullscreen = true;

			this.graphContainer.classList.toggle('is-fullscreen', true);
			this.appendChild(this.mockGraphContainer);
			this.appendChild(this.blurContainer);
			this.fullscreenExitHandler = onClickOutside(this.graphContainer, () => {
				this.disableFullscreen();
			});
			this.graphContainer.onkeyup = e => {
				if (e.key === 'Escape' || e.key === 'f') this.disableFullscreen();
			};
			this.renderActionContainer();

			this.app.renderer.resize(this.graphContainer.clientWidth, this.graphContainer.clientHeight);
			this.colors = getGraphColors(this.graphContainer);
			this.resetNodeFill();

			this.resetZoom(true);
		}

		disableFullscreen() {
			if (!this.isFullscreen) return;

			this.isFullscreen = false;

			this.graphContainer.classList.toggle('is-fullscreen', false);
			this.removeChild(this.mockGraphContainer);
			this.removeChild(this.blurContainer);
			this.fullscreenExitHandler!();
			this.graphContainer.onkeyup = e => {
				if (e.key === 'f') this.enableFullscreen();
			};
			this.renderActionContainer();

			this.app.renderer.resize(this.graphContainer.clientWidth, this.graphContainer.clientHeight);
			this.colors = getGraphColors(this.graphContainer);
			this.resetNodeFill();

			this.resetZoom(true);
		}

		renderActionContainer() {
			this.actionContainer.replaceChildren();
			for (const action of this.config.actions) {
				const actionElement = document.createElement('button');
				actionElement.classList.add('graph-action-button');
				this.actionContainer.appendChild(actionElement);

				if (action === 'fullscreen') {
					actionElement.innerHTML = this.isFullscreen ? icons.minimize : icons.maximize;
					actionElement.onclick = (e) => {
						this.isFullscreen ? this.disableFullscreen() : this.enableFullscreen();
						e.stopPropagation();
					};
					actionElement.oncontextmenu = (e) => {
						showContextMenu(e, [
							{ text: 'Minimize', icon: icons.minimize, onClick: () => this.disableFullscreen() },
							{ text: 'Maximize', icon: icons.maximize, onClick: () => this.enableFullscreen() },
						]);
					};
				} else if (action === 'depth') {
					actionElement.innerHTML = icons[('graph' + this.config.depth) as keyof typeof icons];
					actionElement.onclick = (e) => {
						this.config.depth = (this.config.depth + 1) % MAX_DEPTH;
						this.setup();
						this.renderActionContainer();
						this.resetZoom();
						e.stopPropagation();
					};
					actionElement.oncontextmenu = (e) => {
						showContextMenu(
							e,
							Array.from({ length: MAX_DEPTH }, (_, i) => ({
								text:
									i === MAX_DEPTH - 1
										? 'Show Entire Graph'
										: i === 0
											? 'Show Only Current'
											: i === 1
												? 'Show Adjacent'
												: `Show Distance ${i}`,
								icon: icons[('graph' + i) as keyof typeof icons],
								onClick: () => {
									if (this.config.depth !== i) {
										this.config.depth = i;
										this.setup();
										this.renderActionContainer();
										this.resetZoom();
									}
								},
							})),
						);
					};
				} else if (action === 'reset-zoom') {
					actionElement.innerHTML = icons.focus;
					actionElement.onclick = (e) => {
						this.resetZoom();
						e.stopPropagation();
					};
				} else if (action === 'render-arrows') {
					actionElement.innerHTML = this.config.renderArrows ? icons.arrow : icons.line;
					actionElement.onclick = (e) => {
						this.config.renderArrows = !this.config.renderArrows;
						this.renderActionContainer();
						e.stopPropagation();
					};
					actionElement.oncontextmenu = (e) => {
						showContextMenu(e, [
							{ text: 'Render Arrows', icon: icons.arrow, onClick: () => (this.config.renderArrows = true) },
							{ text: 'Render Lines', icon: icons.line, onClick: () => (this.config.renderArrows = false) },
						]);
					};
				} else if (action === "settings") {
					actionElement.innerHTML = icons.settings;
					actionElement.onclick = (_) => {
						const chargeForceSlider = createValueSlider('Repel Force', this.config.repelForce, 0, 500, 1, (value) => {
							this.config.repelForce = value;
							this.simulationUpdate();
						});

						const centerForceSlider = createValueSlider('Center Force', this.config.centerForce, 0, 200, 1, (value) => {
							this.config.centerForce = value;
							this.simulationUpdate();
						});

						const nodeForceSlider = createValueSlider('Node Force', this.config.nodeForce, 0, 1, 0.01, (value) => {
							this.config.nodeForce = value;
							this.simulationUpdate();
						});

						const colliderPaddingSlider = createValueSlider('Collider Padding', this.config.colliderPadding, 0, 100, 1, (value) => {
							this.config.colliderPadding = value;
							this.simulationUpdate();
						});

                        const linkDistanceSlider = createValueSlider('Link Distance', this.config.linkDistance, 0, 500, 1, (value) => {
                            this.config.linkDistance = value;
                            this.simulationUpdate();
                        });

						showPopupMenu(this.actionContainer, [
							chargeForceSlider,
							centerForceSlider,
							nodeForceSlider,
							colliderPaddingSlider,
                            linkDistanceSlider,
						]);
					}
				}
			}
		}

		async mountGraph() {
			this.app = new PIXI.Application();
			await this.app.init({
				antialias: true,
				backgroundAlpha: 0,
				resolution: 4,
				resizeTo: this.graphContainer,
			} as PIXI.ApplicationOptions);
			this.graphContainer.appendChild(this.app.canvas);

			this.links = new PIXI.Graphics();
			this.arrows = new PIXI.Graphics();
			this.app.stage.sortableChildren = true;
			this.app.stage.addChild(this.links);
			this.app.stage.addChild(this.arrows);
			this.app.ticker.add(ticker => {
				this.tick(ticker);
			});
		}

		processSitemapData(siteData: Sitemap): { nodes: NodeData[]; links: LinkData[] } {
			let slug = this.currentPage;

			const links: LinkData[] = [];
			const tags: Set<string> = new Set();

            let corrected_data = Object.entries(siteData)
                .map(([k, v]) => [simplifySlug(k), v] as const);
            if (!this.config.renderUnresolved) {
                corrected_data = corrected_data.filter(([_, v]) => v.exists);
            }
            const data = new Map(corrected_data);

			let depth = this.config.depth;
			if (depth >= 5) depth = -1;

			const validLinks = new Set(data.keys());
			for (const [source, details] of data.entries()) {
				const outgoing = details.links ?? [];
				for (const dest of outgoing) {
					if (validLinks.has(dest)) {
						links.push({ source: source as unknown as NodeData, target: dest as unknown as NodeData });
					}
				}

				if (this.config.tagRenderMode === "node" || this.config.tagRenderMode === "both") {
					for (const tag of details.tags) {
						tags.add(tag);
						links.push({ source: source as unknown as NodeData, target: tag as unknown as NodeData });
					}
				}
			}

			const neighbourhood = new Set<string>();
			// __SENTINEL is used to separate levels in the BFS
			const queue: (string | '__SENTINEL')[] = [slug, '__SENTINEL'];

			if (depth !== -1) {
				while (depth >= 0 && queue.length > 0) {
					const current = queue.shift()!;

					if (current === '__SENTINEL') {
						depth -= 1;
						if (queue.length === 0) {
							break;
						}
						queue.push('__SENTINEL');
					} else if (neighbourhood.has(current)) {
						continue;
					} else {
						neighbourhood.add(current);

						for (const l of links) {
							const source = l.source as unknown as string;
							const target = l.target as unknown as string;

							if (source === current) {
								queue.push(target);
							}
							if (target === current) {
								queue.push(source);
							}
						}
					}
				}
			} else {
				validLinks.forEach(id => neighbourhood.add(id));
				if (this.config.tagRenderMode === "node" || this.config.tagRenderMode === "both")  {
					tags.forEach(tag => neighbourhood.add(tag));
				}
			}

			const nodes: NodeData[] = [];
			for (const id of neighbourhood) {
				const node = data.get(id);
				if (!node) continue;

				const neighborCount = (node.links?.length ?? 0) + (node.backlinks?.length ?? 0);


				// Chain of declarations determines style priority
				let style: NodeStyle = this.config.nodeDefaultStyle as NodeStyle;
				if (this.visitedPages.has(id)) {
					style = {...style, ...this.config.nodeVisitedStyle as NodeStyle};
				}

				if (this.config.tagRenderMode === "same" || this.config.tagRenderMode === "both") {
					style = {...style, ...node.tags.reduce((acc, tag) => ({ ...acc, ...this.config.tagStyles[tag] }), {}) as NodeStyle};
				}

				if (id === this.currentPage) {
					style = {...style, ...this.config.nodeCurrentStyle as NodeStyle};
				}

				if (!node.exists) {
					style = {...style, ...this.config.nodeUnresolvedStyle as NodeStyle};
				}

				// Magick
				const scaleFactor = Math.max(0.00000001, (-9.67101 * 0.99868 ** neighborCount + 10.6354) ** style.neighborScale * style.nodeScale);
				const computedSize = style.shapeSize * scaleFactor;
				if (style.shape === "circle-hollow") {
					style.strokeWidth = Math.max(1, style.strokeWidth);
				} else {
					style.strokeWidth = 0;
				}

				nodes.push({
					id: id,
					exists: node.exists,
					text: node.title,
					tags: (node.tags ?? []),
					neighborCount,

					color: style.color,
					shape: style.shape,
					shapeSize: style.shapeSize,
					strokeWidth: style.strokeWidth,

					// TODO: computedSize may be removed if no use for it is found
					computedSize: computedSize,
					fullRadius: computedSize + style.strokeWidth / 2,
					colliderSize: (computedSize + style.strokeWidth) * style.colliderScale,
				});
			}

			for (const tag of tags) {
				nodes.push({
					id: tag,
					exists: true,
					text: tag,
					tags: [tag],
					type: "tag",
					neighborCount: 1,

					...this.config.tagDefaultStyle,
					...this.config.tagStyles[tag] ?? {} as Partial<NodeStyle>,
				});
			}

			return {
				nodes,
				links: links.filter(
					l =>
						neighbourhood.has(l.source as unknown as string) &&
						neighbourhood.has(l.target as unknown as string),
				),
			};
		}

		simulationUpdate() {
            const linkForce = d3.forceLink(this.processedData.links).id((d: any) => d.id)
			if (this.config.linkDistance) {
                linkForce.distance(this.config.linkDistance);
            }

			this.simulation
				.stop()
				.force('link', linkForce)
				.force('charge', d3.forceManyBody().distanceMax(500).strength(-this.config.repelForce))
				.force('forceX', d3.forceX().strength(this.config.nodeForce))
				.force('forceY', d3.forceY().strength(this.config.nodeForce))
				.force('collision', d3.forceCollide().radius((node) => (node as NodeData).colliderSize! + this.config.colliderPadding))
				.force('center', d3.forceCenter(this.config.centerForce))
				.alpha(1)
				.restart();
		}

		resetStyle() {
			this.animator.startAnimationsTo({
				...this.defaultColorTransitions,
				labelOffset: 'default',
			});
			this.animator.startAnimation('labelOpacity', this.getCurrentLabelOpacity());
			this.animator.startAnimation('labelOpacityHover', this.getCurrentLabelOpacity());
		}

		getCurrentLabelOpacity(k: number = this.transform.k): number {
			return Math.max((k * this.config.labelOpacityScale - 1) / 3.75, 0);
		}

		cleanup() {
			if (this.simulation) {
				this.app.stage.removeChildren();
				this.app.stage.addChild(this.links);
				this.app.stage.addChild(this.arrows);
				this.links.clear();
				this.arrows.clear();
				this.simulation.stop();
				this.simulation.nodes([]);
				this.simulation.force('link', null);
				this.currentlyHovered = '';
				this.zoomTransform = d3.zoomIdentity;
				this.centerTransform = d3.zoomIdentity;
				this.transform = d3.zoomIdentity;
			}
		}

		findOverlappingNode(x: number, y: number): NodeData | undefined {
			for (const node of this.simulation.nodes()) {
				if ((node.x! - x) ** 2 + (node.y! - y) ** 2 <= node.fullRadius! ** 2) {
					return node;
				}
			}

			return undefined;
		}

		renderNodes() {
			for (const node of this.simulation.nodes()) {
				node.node = new PIXI.Graphics();
				this.setNodeFill(node);

				const nodeText = new PIXI.Text({
					text: node.text || node.id,
					style: {
						fill: 0xffffff,
						fontSize: this.config.labelFontSize,
					},
					zIndex: 100,
				});
				nodeText.anchor.set(0.5, 0.5);
				nodeText.alpha = this.animator.getValue('labelOpacity');

                this.app.stage.addChild(node.node);
                if (this.config.renderLabels) {
                    node.label = nodeText;
                    this.app.stage.addChild(nodeText);
                }
			}
		}

		setNodeFill(node: NodeData) {
			node.node!._zIndex = 1;
			node.node!.circle(0, 0, node.computedSize!);
			if (node.shape !== "circle-hollow") {
				node.node!.fill(0xffffff);
			} else {
				node.node!.fill(this.colors.backgroundColor);
			}
		}

		resetNodeFill() {
			for (const node of this.simulation.nodes()) {
				node.node!.clear();
				this.setNodeFill(node);
			}
		}

		setup() {
			this.cleanup();

			this.processedData = this.processSitemapData(this.sitemap);

			this.currentNode = this.processedData.nodes.find(node => node.id === this.currentPage);
            this.scale = this.config.scale;
            this.zoomTransform = this.zoomTransform.scale(this.scale);

			this.simulation = d3.forceSimulation<NodeData>(this.processedData.nodes);
			this.simulationUpdate();

			this.renderNodes();

            if (this.config.enableDrag) {
                let dragX = 0;
                let dragY = 0;
                d3.select(this.app.canvas).call(
                    (d3.drag().container(this.app.canvas) as unknown as d3.DragBehavior<HTMLCanvasElement, unknown, unknown>)
                        .subject(event => {
                            const [x, y] = this.transform.invert([event.x, event.y]);
                            return this.findOverlappingNode(x, y);
                        })
                        .on('start', e => {
                            if (!e.subject) return;

                            this.userZoomed = true;

                            if (!e.active) this.simulation.alphaTarget(0.3).restart();

                            e.subject.fx = e.subject.x;
                            e.subject.fy = e.subject.y;
                            dragX = e.x;
                            dragY = e.y;
                        })
                        .on('drag', e => {
                            if (!e.subject) return;

                            dragX += e.dx / this.animator.getValue('zoom');
                            dragY += e.dy / this.animator.getValue('zoom');

                            e.subject.fx = dragX;
                            e.subject.fy = dragY;
                        })
                        .on('end', e => {
                            if (!e.subject) return;

                            if (!e.active) this.simulation.alphaTarget(0);
                            e.subject.fx = null;
                            e.subject.fy = null;
                        }),
                );
            }

            if (this.config.enableHover) {
                d3.select(this.app.canvas).on('mousemove', (e: MouseEvent) => {
                    const [x, y] = this.transform.invert([e.offsetX, e.offsetY]);
                    const closestNode = this.findOverlappingNode(x, y);

                    if (closestNode) {
                        this.currentlyHovered = closestNode.id;
						this.isHovering = true;
						prefetch(ensureLeadingSlash(closestNode.id));
                        this.animator.startAnimationsTo({
                            ...this.hoverColorTransitions,

							labelOpacity: 'blur',
							labelOpacityHover: 'hover',
                            labelOffset: 'hover',
                        });
                    } else if (this.currentlyHovered) {
						this.isHovering = false;
                        this.resetStyle();
                        this.animator.setOnFinished('nodeColorHover', () => {
                            this.currentlyHovered = '';
                        });
                    }
                });
            }

			d3.select(this.app.canvas).on('click', (e: MouseEvent) => {
				const [x, y] = this.transform.invert([e.offsetX, e.offsetY]);
				const closestNode = this.findOverlappingNode(x, y);
				if (closestNode && closestNode.exists && !(closestNode.type === "tag" || closestNode.id === this.currentPage)) {
					const clickTime = Date.now();
					if (!this.requireDblClick || (clickTime - this.lastClick < 500 && closestNode === this.lastClickedNode)) {
						if (this.config.trackVisitedPages) {
							addToVisitedEndpoints(closestNode.id);
						}
						window.open(ensureLeadingSlash(closestNode.id), '_self');
					}
					this.lastClick = clickTime;
					this.lastClickedNode = closestNode;
				}
			});

            if (this.config.enableZoom) {
                d3.select(this.app.canvas as HTMLCanvasElement).call(
                    (this.zoomBehavior = (d3.zoom() as d3.ZoomBehavior<HTMLCanvasElement, unknown>)
                        .scaleExtent([this.config.minZoom, this.config.maxZoom])
                        .on('zoom', ({transform}: { transform: d3.ZoomTransform }) => {
                            this.userZoomed = true;
                            this.zoomTransform = transform;
                            this.updateTransform();
                        })),
                );
            }
		}

		resetZoom(immediate: boolean = false) {
			this.userZoomed = false;
			// @ts-ignore
			this.app.canvas.__zoom = d3.zoomIdentity;
			this.zoomTransform = d3.zoomIdentity.scale(this.scale);
			this.updateCenterTransform();

			this.updateTransform(immediate);
		}

		updateTransform(immediate: boolean = false) {
			this.transform = this.zoomTransform
				.translate(this.centerTransform.x, this.centerTransform.y)
				.scale(this.centerTransform.k);

			const values: { zoom: number; transformX: number; transformY: number, labelOpacity?: number } = {
				zoom: this.transform.k,
				transformX: this.transform.x,
				transformY: this.transform.y,
			};
			if (!this.currentlyHovered) {
				values.labelOpacity = this.getCurrentLabelOpacity(this.transform.k);
			}

			if (immediate) {
				this.animateZoomOverride = true;
				this.animator.setValues(values);
			} else {
				this.animator.startAnimations(values);
			}
        }

		/**
		 * Updates the center transform to keep the current node in the center of the screen.
		 * @returns {boolean} Whether the transform was updated.
		 */
		updateCenterTransform(): boolean {
			let x;
			let y;

			if (this.currentNode) {
				x = this.graphContainer.clientWidth / (2 * this.scale) - this.scale * this.currentNode.x!;
				y = this.graphContainer.clientHeight / (2 * this.scale) - this.scale * this.currentNode.y!;
			} else {
				x = this.graphContainer.clientWidth / (2 * this.scale);
				y = this.graphContainer.clientHeight / (2 * this.scale);
			}

			if (this.centerTransform.x !== x || this.centerTransform.y !== y) {
				this.centerTransform = new d3.ZoomTransform(this.scale, x, y);
				return true;
			}

			return false;
		}

        zoomAnimating() {
			if (this.animateZoomOverride) {
				return true;
			}
            return this.animator.isAnimating('zoom') || this.animator.isAnimating('transformX') || this.animator.isAnimating('transformY');
        }

		tick(ticker: PIXI.Ticker) {
			this.animator.update(ticker.deltaMS);

			if (!this.userZoomed) {
				const updated = this.updateCenterTransform();
				if (updated) {
					this.updateTransform();
				}
			}

			if (this.zoomAnimating()) {
				this.app.stage.updateTransform({
					scaleX: this.animator.getValue('zoom'),
					scaleY: this.animator.getValue('zoom'),
					x: this.animator.getValue('transformX'),
					y: this.animator.getValue('transformY'),
				});
				this.animateZoomOverride = false;
			}

			for (const node of this.simulation.nodes()) {
				const isHovered = this.currentlyHovered !== '' && node.id === this.currentlyHovered;

                if (this.config.renderLabels) {
                    const labelOffset = node.fullRadius! + (isHovered
                        ? this.animator.getValue('labelOffset')
                        : this.config.labelOffset);
                    const labelOpacity = isHovered
                        ? this.animator.getValue('labelOpacityHover')
                        : this.animator.getValue('labelOpacity');
                    const labelColor = this.animator.getValue(isHovered ? 'labelColorHover' : 'labelColor');

                    node.label!.scale.set(1);
                    node.label!.position.set(node.x!, node.y! + labelOffset);
                    node.label!.alpha = labelOpacity;
                    node.label!.tint = labelColor;
                }

                const nodeZIndex = isHovered ? 100 : 1;
				const nodeColor = this.animator.getValue(node.color + (isHovered ? 'Hover' : '') as any) as string;

				if (node.shape === "circle-hollow") {
					node.node!.stroke({
						color: nodeColor,
						width: node.strokeWidth,
					})
				} else {
					node.node!.tint = nodeColor;
				}
				node.node!.position.set(node.x!, node.y!);
				node.node!._zIndex = nodeZIndex;
			}

			this.links.clear();

			const adjacentLinks = [];
			// FIXME: make adjacent links render above other links, probably some drawing order stuff
			for (const link of this.processedData.links) {
				let isAdjacent =
					this.currentlyHovered !== '' &&
					(link.source.id === this.currentlyHovered || link.target.id === this.currentlyHovered);

				if (isAdjacent) {
					adjacentLinks.push(link);
				} else {
					this.renderArrow(link, false);
				}
			}

			for (const link of adjacentLinks) {
				this.renderArrow(link, true);
			}
		}

		renderArrow(link: LinkData, isAdjacent: boolean): void {
            const linkZoomLevel = this.config.scaleLinks ? this.animator.getValue('zoom') : 1;
            const arrowZoomLevel = this.config.scaleArrows ? this.animator.getValue('zoom') : 2;
			const incAngle = Math.atan2(link.target.y! - link.source.y!, link.target.x! - link.source.x!);
			const outAngle = Math.atan2(link.source.y! - link.target.y!, link.source.x! - link.target.x!);

			const xStart = link.source.x! - link.source.fullRadius! * Math.cos(outAngle);
			const yStart = link.source.y! - link.source.fullRadius! * Math.sin(outAngle);
			const xEnd = link.target.x! - link.target.fullRadius! * Math.cos(incAngle);
			const yEnd = link.target.y! - link.target.fullRadius! * Math.sin(incAngle);

			this.links
				.moveTo(xStart, yStart)
				.lineTo(xEnd, yEnd)
				.stroke({
					color: isAdjacent ? this.animator.getValue('linkColorHover') : this.animator.getValue('linkColor'),
					width: this.config.linkWidth / linkZoomLevel,
				})
				.zIndex = (isAdjacent && this.isHovering) ? 10 : 0;

			if (this.config.renderArrows && this.zoomTransform.k > this.config.minZoomArrows) {
				const x = xEnd - (this.config.linkWidth / arrowZoomLevel / 2) * Math.cos(incAngle);
				const y = yEnd - (this.config.linkWidth / arrowZoomLevel / 2) * Math.sin(incAngle);
                const arrowSize = 1.5 * this.config.arrowSize / arrowZoomLevel;
				this.links
					.moveTo(x, y)
					.lineTo(
                        (x - arrowSize * Math.cos(incAngle - this.config.arrowAngle)),
                        (y - arrowSize * Math.sin(incAngle - this.config.arrowAngle))
                    )
					.lineTo(
                        (x - arrowSize * Math.cos(incAngle + this.config.arrowAngle)),
                        (y - arrowSize * Math.sin(incAngle + this.config.arrowAngle))
                    )
					.lineTo(x, y)
					.fill(isAdjacent ? this.animator.getValue('linkColorHover') : this.animator.getValue('linkColor'));
			}
		}
	}

	customElements.define('graph-component', GraphComponent);
</script>

