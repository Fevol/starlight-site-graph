---
import { ContentDetails } from './types';
import { GraphConfig } from '../config';
const { config, sitemap } = Astro.props as
	{ config: GraphConfig, sitemap: Record<string, ContentDetails> };
---


<graph-component data-config={JSON.stringify(config)} data-sitemap={JSON.stringify(sitemap)}></graph-component>

<script>
	import * as d3 from 'd3';
	import { Application, type ApplicationOptions, Graphics, Text, Ticker } from 'pixi.js';
	import type { GraphConfig } from '../config';
	import { Animator } from './animator';
	import { showContextMenu } from './context-menu';
	import {
		addToVisitedEndpoints,
		createValueSlider,
		getVisitedEndpoints,
		onClickOutside,
		simplifySlug,
		stripSlashes
	} from './util';
	import type { ContentDetails, LinkData, NodeData } from './types';
	import { animatables } from './animatables';
	import { icons } from './icons';
	import { ensureLeadingSlash } from '../integrationUtil';
	import { getGraphColors, type GraphColorConfig } from '../color';
	import {showPopupMenu} from "./popup-menu";


    const MAX_DEPTH = 6;

	export class GraphComponent extends HTMLElement {
		static observedValues = ["config", "sitemap"];

		graphContainer: HTMLElement;
		mockGraphContainer: HTMLElement;
		actionContainer: HTMLElement;
		blurContainer: HTMLElement;

		app!: Application;
		simulation!: d3.Simulation<NodeData, undefined>;
		zoomBehavior!: d3.ZoomBehavior<HTMLCanvasElement, unknown>;
		zoomTransform: d3.ZoomTransform;
		centerTransform: d3.ZoomTransform;
		transform: d3.ZoomTransform;
		userZoomed: boolean = false;
		currentNode: NodeData | undefined;

		links!: Graphics;
		arrows!: Graphics;

        scale: number;
		config!: GraphConfig;
		sitemap!: Record<string, ContentDetails>;

		colors!: GraphColorConfig;
		processedData!: ReturnType<typeof this.processSitemapData>;
		animator: Animator<ReturnType<typeof animatables>>;

		currentlyHovered: string = '';
		isFullscreen: boolean = false;
		fullscreenExitHandler?: (options: (boolean | EventListenerOptions | undefined)) => void;

		currentPage: string = stripSlashes(location.pathname) + '/';

		visitedPages: Set<string> = getVisitedEndpoints();

		constructor() {
			super();

			try {
				this.config = JSON.parse(this.dataset.config || '{}');
			} catch (e) { console.error("[SITE GRAPH PLUGIN] " + e.message); }
			try {
				this.sitemap = JSON.parse(this.dataset.sitemap || '{}');
			} catch (e) { console.error("[SITE GRAPH PLUGIN] " + e.message); }

			this.config.depth = Math.min(this.config.depth, 5);

			this.zoomTransform = d3.zoomIdentity;
			this.centerTransform = d3.zoomIdentity;
			this.transform = d3.zoomIdentity;

			this.classList.add('graph-component');

			this.graphContainer = document.createElement('div');
			this.graphContainer.classList.add('graph-container');
			this.graphContainer.onkeyup = e => {
				if (e.key === 'f') this.enableFullscreen();
			};
			this.graphContainer.tabIndex = 0;
			this.appendChild(this.graphContainer);

			this.actionContainer = document.createElement('div');
			this.actionContainer.classList.add('graph-action-container');
			this.renderActionContainer();
			this.graphContainer.appendChild(this.actionContainer);

			this.mockGraphContainer = document.createElement('div');
			this.mockGraphContainer.classList.add('graph-container');

			this.blurContainer = document.createElement('div');
			this.blurContainer.classList.add('background-blur');

			this.colors = getGraphColors();

			this.animator = new Animator<ReturnType<typeof animatables>>(animatables(this.config, this.colors));

			this.mountGraph().then(() => {
				this.setup();
			});
		}

		override remove() {
			this.app.destroy();
			this.graphContainer.remove();
			this.mockGraphContainer.remove();
			this.blurContainer.remove();

			super.remove();
		}

		enableFullscreen() {
			if (this.isFullscreen) return;

			this.isFullscreen = true;

			this.graphContainer.classList.toggle('is-fullscreen', true);
			this.appendChild(this.mockGraphContainer);
			this.appendChild(this.blurContainer);
			this.fullscreenExitHandler = onClickOutside(this.graphContainer, () => {
				this.disableFullscreen();
			});
			this.graphContainer.onkeyup = e => {
				if (e.key === 'Escape' || e.key === 'f') this.disableFullscreen();
			};
			this.renderActionContainer();

			this.app.renderer.resize(this.graphContainer.clientWidth, this.graphContainer.clientHeight);

			this.resetZoom(true);
		}

		disableFullscreen() {
			if (!this.isFullscreen) return;

			this.isFullscreen = false;

			this.graphContainer.classList.toggle('is-fullscreen', false);
			this.removeChild(this.mockGraphContainer);
			this.removeChild(this.blurContainer);
			this.fullscreenExitHandler!();
			this.graphContainer.onkeyup = e => {
				if (e.key === 'f') this.enableFullscreen();
			};
			this.renderActionContainer();

			this.app.renderer.resize(this.graphContainer.clientWidth, this.graphContainer.clientHeight);

			this.resetZoom(true);
		}

		renderActionContainer() {
			this.actionContainer.replaceChildren();
			for (const action of this.config.actions) {
				const actionElement = document.createElement('button');
				actionElement.classList.add('graph-action-button');
				this.actionContainer.appendChild(actionElement);

				if (action === 'fullscreen') {
					actionElement.innerHTML = this.isFullscreen ? icons.minimize : icons.maximize;
					actionElement.onclick = (e) => {
						this.isFullscreen ? this.disableFullscreen() : this.enableFullscreen();
						e.stopPropagation();
					};
					actionElement.oncontextmenu = (e) => {
						showContextMenu(e, [
							{ text: 'Minimize', icon: icons.minimize, onClick: () => this.disableFullscreen() },
							{ text: 'Maximize', icon: icons.maximize, onClick: () => this.enableFullscreen() },
						]);
					};
				} else if (action === 'depth') {
					actionElement.innerHTML = icons[('graph' + this.config.depth) as keyof typeof icons];
					actionElement.onclick = (e) => {
						this.config.depth = (this.config.depth + 1) % MAX_DEPTH;
						this.setup();
						this.renderActionContainer();
						this.resetZoom();
						e.stopPropagation();
					};
					actionElement.oncontextmenu = (e) => {
						showContextMenu(
							e,
							Array.from({ length: MAX_DEPTH }, (_, i) => ({
								text:
									i === MAX_DEPTH - 1
										? 'Show Entire Graph'
										: i === 0
											? 'Show Only Current'
											: i === 1
												? 'Show Adjacent'
												: `Show Distance ${i}`,
								icon: icons[('graph' + i) as keyof typeof icons],
								onClick: () => {
									if (this.config.depth !== i) {
										this.config.depth = i;
										this.setup();
										this.renderActionContainer();
										this.resetZoom();
									}
								},
							})),
						);
					};
				} else if (action === 'reset-zoom') {
					actionElement.innerHTML = icons.focus;
					actionElement.onclick = (e) => {
						this.resetZoom();
						e.stopPropagation();
					};
				} else if (action === 'render-arrows') {
					actionElement.innerHTML = this.config.renderArrows ? icons.arrow : icons.line;
					actionElement.onclick = (e) => {
						this.config.renderArrows = !this.config.renderArrows;
						this.renderActionContainer();
						e.stopPropagation();
					};
					actionElement.oncontextmenu = (e) => {
						showContextMenu(e, [
							{ text: 'Render Arrows', icon: icons.arrow, onClick: () => (this.config.renderArrows = true) },
							{ text: 'Render Lines', icon: icons.line, onClick: () => (this.config.renderArrows = false) },
						]);
					};
				} else if (action === "settings") {
					actionElement.innerHTML = icons.settings;
					actionElement.onclick = (_) => {
						const chargeForceSlider = createValueSlider('Repel Force', this.config.repelForce, 0, 500, 1, (value) => {
							this.config.repelForce = value;
							this.simulationUpdate();
						});

						const centerForceSlider = createValueSlider('Center Force', this.config.centerForce, 0, 200, 1, (value) => {
							this.config.centerForce = value;
							this.simulationUpdate();
						});

						const nodeForceSlider = createValueSlider('Node Force', this.config.nodeForce, 0, 1, 0.01, (value) => {
							this.config.nodeForce = value;
							this.simulationUpdate();
						});

						const collisionForceSlider = createValueSlider('Collision Force', this.config.collisionForce, 0, 100, 1, (value) => {
							this.config.collisionForce = value;
							this.simulationUpdate();
						});

						showPopupMenu(this.actionContainer, [
							chargeForceSlider,
							centerForceSlider,
							nodeForceSlider,
							collisionForceSlider,
						]);
					}
				}
			}
		}

		async mountGraph() {
			this.app = new Application();
			await this.app.init({
				antialias: true,
				backgroundAlpha: 0,
				resolution: 4,
				resizeTo: this.graphContainer,
			} as ApplicationOptions);
			this.graphContainer.appendChild(this.app.canvas);

			this.links = new Graphics();
			this.arrows = new Graphics();
			this.app.stage.sortableChildren = true;
			this.app.stage.addChild(this.links);
			this.app.stage.addChild(this.arrows);
			this.app.ticker.add(ticker => {
				this.tick(ticker);
			});
		}

		processSitemapData(siteData: Record<string, ContentDetails>): { nodes: NodeData[]; links: LinkData[] } {
			let slug = this.currentPage;
			const links: LinkData[] = [];
			const tags: string[] = [];
			const data: Map<string, ContentDetails> = new Map(
				Object.entries<ContentDetails>(siteData).map(([k, v]) => [simplifySlug(k), v]),
			);

			let depth = this.config.depth;
			if (depth >= 5) depth = -1;

			const validLinks = new Set(data.keys());
			for (const [source, details] of data.entries()) {
				const outgoing = details.links ?? [];
				for (const dest of outgoing) {
					if (validLinks.has(dest)) {
						links.push({ source: source as unknown as NodeData, target: dest as unknown as NodeData });
					}
				}

				if (this.config.showTags) {
					const localTags = details.tags
						.filter(tag => !this.config.removeTags.includes(tag))
						.map(tag => simplifySlug('tags/' + tag));

					tags.push(...localTags.filter(tag => !tags.includes(tag)));

					for (const tag of localTags) {
						links.push({ source: source as unknown as NodeData, target: tag as unknown as NodeData });
					}
				}
			}

			const neighbourhood = new Set<string>();
			// __SENTINEL is used to separate levels in the BFS
			const queue: (string | '__SENTINEL')[] = [slug, '__SENTINEL'];

			if (depth !== -1) {
				while (depth >= 0 && queue.length > 0) {
					const current = queue.shift()!;

					if (current === '__SENTINEL') {
						depth -= 1;
						if (queue.length === 0) {
							break;
						}
						queue.push('__SENTINEL');
					} else if (neighbourhood.has(current)) {
						continue;
					} else {
						neighbourhood.add(current);
						const outgoing = links.filter(l => (l.source as unknown as string) === current);
						const incoming = links.filter(l => (l.target as unknown as string) === current);
						queue.push(
							...outgoing.map(l => l.target as unknown as string),
							...incoming.map(l => l.source as unknown as string),
						);
					}
				}
			} else {
				validLinks.forEach(id => neighbourhood.add(id));
				if (this.config.showTags) tags.forEach(tag => neighbourhood.add(tag));
			}

			return {
				nodes: [...neighbourhood].map(url => {
					return {
						id: url,
						text: url.startsWith('tags/') ? '#' + url.substring(5) : (data.get(url)?.title ?? url),
						tags: data.get(url)?.tags ?? [],
						neighborCount: (data.get(url)?.links?.length ?? 0) + (data.get(url)?.backlinks?.length ?? 0),
						size:
							this.config.nodeSize +
							(((data.get(url)?.links?.length ?? 0) + (data.get(url)?.backlinks?.length ?? 0)) ** 0.8) *
                            this.config.nodeSizeLinkScale,
					};
				}),
				links: links.filter(
					l =>
						neighbourhood.has(l.source as unknown as string) &&
						neighbourhood.has(l.target as unknown as string),
				),
			};
		}

		simulationUpdate() {
			this.simulation
				.stop()
				.force(
					'link',
					d3.forceLink(this.processedData.links).id((d: any) => d.id)
					// .distance(250),
				)
				.force('charge', d3.forceManyBody().distanceMax(500).strength(-this.config.repelForce))
				.force('forceX', d3.forceX().strength(this.config.nodeForce))
				.force('forceY', d3.forceY().strength(this.config.nodeForce))
				.force('collision', d3.forceCollide().radius(this.config.collisionForce))
				.force('center', d3.forceCenter(this.config.centerForce))
				.alpha(1)
				.restart();
		}

		resetStyle() {
			this.animator.startAnimationsTo({
				nodeColorHover: 'default',
				nodeColor: 'default',
				visitedNodeColorHover: 'default',
				visitedNodeColor: 'default',
				currentNodeColorHover: 'default',
				currentNodeColor: 'default',

				linkColorHover: 'default',
				linkColor: 'default',

				labelOffset: 'default',
				labelColorHover: 'default',
			});
			this.animator.startAnimation('labelOpacity', this.getCurrentLabelOpacity());
			this.animator.startAnimation('labelOpacityHover', this.getCurrentLabelOpacity());
		}

		resetZoom(immediate: boolean = false) {
			this.userZoomed = false;
			// @ts-ignore
			this.app.canvas.__zoom = d3.zoomIdentity;
			this.zoomTransform = d3.zoomIdentity;
			this.updateCenterTransform(immediate);
		}

		getCurrentLabelOpacity(k: number = this.transform.k): number {
			return Math.max((k * this.config.labelOpacityScale - 1) / 3.75, 0);
		}

		cleanup() {
			if (this.simulation) {
				this.app.stage.removeChildren();
				this.app.stage.addChild(this.links);
				this.app.stage.addChild(this.arrows);
				this.links.clear();
				this.arrows.clear();
				this.simulation.stop();
				this.simulation.nodes([]);
				this.simulation.force('link', null);
				this.currentlyHovered = '';
				this.zoomTransform = d3.zoomIdentity;
				this.centerTransform = d3.zoomIdentity;
				this.transform = d3.zoomIdentity;
			}
		}

		getNodeColor(node: NodeData, hover: boolean): string {
			let color = '';
			if (node.id === this.currentPage) {
				color = 'currentNodeColor';
			} else if (this.visitedPages.has(node.id)) {
				color = 'visitedNodeColor';
			} else {
				color = 'nodeColor';
			}
			// @ts-ignore ts does not understand that the keys are valid
			return this.animator.getValue(color + (hover ? 'Hover' : '') as any) as string;
		}

		findOverlappingNode(x: number, y: number): NodeData | undefined {
			for (const node of this.simulation.nodes()) {
				if ((node.x! - x) ** 2 + (node.y! - y) ** 2 <= node.size! ** 2) {
					return node;
				}
			}

			return undefined;
		}

		renderNodes() {
			for (const node of this.simulation.nodes()) {
				const nodeDot = new Graphics();
				nodeDot._zIndex = 1;
				nodeDot.circle(0, 0, node.size!).fill(0xffffff);

				const nodeText = new Text({
					text: node.text || node.id,
					style: {
						fill: 0xffffff,
						fontSize: this.config.labelFontSize,
					},
					zIndex: 100,
				});
				nodeText.anchor.set(0.5, 0.5);
				nodeText.alpha = this.animator.getValue('labelOpacity');

				node.node = nodeDot;
                this.app.stage.addChild(nodeDot);
                if (this.config.renderLabels) {
                    node.label = nodeText;
                    this.app.stage.addChild(nodeText);
                }
			}
		}

		setup() {
			this.cleanup();

			this.processedData = this.processSitemapData(this.sitemap as Record<string, ContentDetails>);

			this.currentNode = this.processedData.nodes.find(node => node.id === this.currentPage);
            this.scale = this.config.scale;
            this.zoomTransform.k = this.scale;

			this.simulation = d3.forceSimulation<NodeData>(this.processedData.nodes);
			this.simulationUpdate();

			this.renderNodes();

            if (this.config.enableDrag) {
                let dragX = 0;
                let dragY = 0;
                d3.select(this.app.canvas).call(
                    (d3.drag().container(this.app.canvas) as unknown as d3.DragBehavior<HTMLCanvasElement, unknown, unknown>)
                        .subject(event => {
                            const [x, y] = this.transform.invert([event.x, event.y]);
                            return this.findOverlappingNode(x, y);
                        })
                        .on('start', e => {
                            if (!e.subject) return;

                            this.userZoomed = true;

                            if (!e.active) this.simulation.alphaTarget(0.3).restart();

                            e.subject.fx = e.subject.x;
                            e.subject.fy = e.subject.y;
                            dragX = e.x;
                            dragY = e.y;
                        })
                        .on('drag', e => {
                            if (!e.subject) return;

                            dragX += e.dx / this.animator.getValue('zoom');
                            dragY += e.dy / this.animator.getValue('zoom');

                            e.subject.fx = dragX;
                            e.subject.fy = dragY;
                        })
                        .on('end', e => {
                            if (!e.subject) return;

                            if (!e.active) this.simulation.alphaTarget(0);
                            e.subject.fx = null;
                            e.subject.fy = null;
                        }),
                );
            }

            if (this.config.enableHover) {
                d3.select(this.app.canvas).on('mousemove', (e: MouseEvent) => {
                    const [x, y] = this.transform.invert([e.offsetX, e.offsetY]);
                    const closestNode = this.findOverlappingNode(x, y);

                    if (closestNode) {
                        this.currentlyHovered = closestNode.id;
                        this.animator.startAnimationsTo({
                            nodeColorHover: 'hover',
                            nodeColor: 'blur',
                            visitedNodeColorHover: 'hover',
                            visitedNodeColor: 'blur',
                            currentNodeColorHover: 'hover',
                            currentNodeColor: 'blur',

                            linkColorHover: 'hover',
                            linkColor: 'blur',

                            labelOpacityHover: 'hover',
                            labelOpacity: 'blur',
                            labelOffset: 'hover',
                            labelColorHover: 'hover',
                        });
                    } else if (this.currentlyHovered) {
                        this.resetStyle();
                        this.animator.setOnFinished('nodeColorHover', () => {
                            this.currentlyHovered = '';
                        });
                    }
                });
            }

			d3.select(this.app.canvas).on('click', (e: MouseEvent) => {
				const [x, y] = this.transform.invert([e.offsetX, e.offsetY]);
				const closestNode = this.findOverlappingNode(x, y);
				if (closestNode) {
					addToVisitedEndpoints(closestNode.id);
					window.open(ensureLeadingSlash(closestNode.id), '_self');
				}
			});

            if (this.config.enableZoom) {
                d3.select(this.app.canvas as HTMLCanvasElement).call(
                    (this.zoomBehavior = (d3.zoom() as d3.ZoomBehavior<HTMLCanvasElement, unknown>)
                        .scaleExtent([this.config.minZoom, this.config.maxZoom])
                        .on('zoom', ({transform}: { transform: d3.ZoomTransform }) => {
                            this.userZoomed = true;

                            this.zoomTransform = transform;
                            this.updateTransform();
                        })),
                );
            }
		}

		updateTransform(immediate: boolean = false) {
			this.transform = this.zoomTransform
				.translate(this.centerTransform.x, this.centerTransform.y)
				.scale(this.centerTransform.k);

			if (immediate) {
				this.animator.setValues({
					zoom: this.transform.k,
					transformX: this.transform.x,
					transformY: this.transform.y,
					labelOpacity: this.getCurrentLabelOpacity(this.transform.k),
				});
			} else {
				this.animator.startAnimations({
					zoom: this.transform.k,
					transformX: this.transform.x,
					transformY: this.transform.y,
					labelOpacity: this.getCurrentLabelOpacity(this.transform.k),
				});
			}
        }

        // FIXME: Called too often in the beginning
		updateCenterTransform(immediate: boolean = false) {
			let x;
			let y;

			if (this.currentNode) {
				x = this.graphContainer.clientWidth / (2 * this.scale) - this.scale * this.currentNode.x!;
				y = this.graphContainer.clientHeight / (2 * this.scale) - this.scale * this.currentNode.y!;
			} else {
				x = this.graphContainer.clientWidth / (2 * this.scale);
				y = this.graphContainer.clientHeight / (2 * this.scale);
			}

			this.centerTransform = new d3.ZoomTransform(this.scale, x, y);

			this.updateTransform(immediate);
            if (!this.userZoomed) {
                this.animator.setOnMultipleFinished(['zoom', 'transformX', 'transformY'], () => {
                    this.userZoomed = true
                });
            }
		}

        zoomAnimating() {
            return this.animator.isAnimating('zoom') || this.animator.isAnimating('transformX') || this.animator.isAnimating('transformY');
        }

		tick(ticker: Ticker) {
			this.animator.update(ticker.deltaMS);

			if (!this.userZoomed) {
				this.updateCenterTransform();
			}

			if (this.zoomAnimating()) {
				this.app.stage.updateTransform({
					scaleX: this.animator.getValue('zoom'),
					scaleY: this.animator.getValue('zoom'),
					x: this.animator.getValue('transformX'),
					y: this.animator.getValue('transformY'),
				});
			}

			for (const node of this.simulation.nodes()) {
				const isHovered = this.currentlyHovered !== '' && node.id === this.currentlyHovered;

                if (this.config.renderLabels) {
                    const labelOffset = isHovered
                        ? this.animator.getValue('labelOffset') + node.size!
                        : this.config.labelOffset + node.size!;
                    const labelOpacity = isHovered
                        ? this.animator.getValue('labelOpacityHover')
                        : this.animator.getValue('labelOpacity');
                    const labelColor = isHovered ? this.animator.getValue('labelColorHover') : this.colors.labelColor;

                    node.label!.scale.set(1);
                    node.label!.position.set(node.x!, node.y! + labelOffset);
                    node.label!.alpha = labelOpacity;
                    node.label!.tint = labelColor;
                }

                const nodeZIndex = isHovered ? 100 : 1;
                const nodeColor = this.getNodeColor(node, isHovered);
				node.node!.tint = nodeColor;
				node.node!.position.set(node.x!, node.y!);
				node.node!._zIndex = nodeZIndex;
			}

			this.links.clear();

			const adjacentLinks = [];
			// FIXME: make adjacent links render above other links, probably some drawing order stuff
			for (const link of this.processedData.links) {
				let isAdjacent =
					this.currentlyHovered !== '' &&
					(link.source.id === this.currentlyHovered || link.target.id === this.currentlyHovered);

				if (isAdjacent) {
					adjacentLinks.push(link);
				} else {
					this.renderArrow(link, false);
				}
			}

			for (const link of adjacentLinks) {
				this.renderArrow(link, true);
			}
		}

		renderArrow(link: LinkData, isAdjacent: boolean): void {
            const linkZoomLevel = this.config.scaleLinks ? this.animator.getValue('zoom') : 1;
            const arrowZoomLevel = this.config.scaleArrows ? this.animator.getValue('zoom') : 2;

			this.links
				.moveTo(link.source.x!, link.source.y!)
				.lineTo(link.target.x!, link.target.y!)
				.fill()
				.stroke({
					color: isAdjacent ? this.animator.getValue('linkColorHover') : this.animator.getValue('linkColor'),
					width: this.config.linkWidth / linkZoomLevel,
				});

			if (this.config.renderArrows) {
				let { x, y } = link.target as { x: number; y: number };
				const angle = Math.atan2(link.target.y! - link.source.y!, link.target.x! - link.source.x!);
				x -= (link.target.size! - this.config.linkWidth / arrowZoomLevel / 2) * Math.cos(angle);
				y -= (link.target.size! - this.config.linkWidth / arrowZoomLevel / 2) * Math.sin(angle);
                const arrowSize = 1.5 * this.config.arrowSize / arrowZoomLevel;
				this.links
					.moveTo(x, y)
					.lineTo(
                        (x - arrowSize * Math.cos(angle - this.config.arrowAngle)),
                        (y - arrowSize * Math.sin(angle - this.config.arrowAngle))
                    )
					.lineTo(
                        (x - arrowSize * Math.cos(angle + this.config.arrowAngle)),
                        (y - arrowSize * Math.sin(angle + this.config.arrowAngle))
                    )
					.lineTo(x, y)
					.fill(isAdjacent ? this.animator.getValue('linkColorHover') : this.animator.getValue('linkColor'));
			}
		}
	}

	customElements.define('graph-component', GraphComponent);
</script>

